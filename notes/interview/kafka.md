# Kafka

## Kafka 与传统消息系统之间的区别

- Kafka 持久化日志，这些日志可以被重复读取和无限期保留
- Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性
- Kafka 支持实时的流式处理

## kafka的ACK的三种机制

Kafka的ACK（确认）机制有三种：0，1，-1。这三种机制会围绕持久性和延时性来比较。

* ACK=0：这是最不可靠的模式。生产者在发送消息后不会等待来自服务器的确认。这意味着消息可能会在发送之后丢失，而生产者将无法知道它是否成功到达服务器。
* ACK=1：这是默认模式，也是一种折衷方式。在这种模式下，生产者会在消息发送后等待来自分区领导者（leader）的确认，但不会等待所有副本（replicas）的确认。这意味着只要消息被写入分区领导者，生产者就会收到确认。如果分区领导者成功写入消息，但在同步到所有副本之前宕机，消息可能会丢失。
* ACK=-1：这是最可靠的模式。在这种模式下，生产者会在消息发送后等待所有副本的确认。只有在所有副本都成功写入消息后，生产者才会收到确认。这确保了消息的可靠性，但会导致更长的延迟。
在选择ACK机制时，需要根据具体的应用场景和需求来权衡持久性和延时性的需求。

## 解释下Kafka中位移（offset）的作用

在Kafka中，每个主题分区下的每条消息都被赋予了一个唯一的ID数值，用于标识它在分区中的位置。这个ID数值，就被称为位移，或者叫偏移量。一旦消息被写入到分区日志，它的位移值将不能被修改。

##  kafka 为什么那么快（高吞吐量和低延迟）？

* 顺序写入和分段日志
* 零拷贝技术（sendfile系统调用），避免了在用户空间和内核空间之间的数据拷贝
* 分区和并行处理
* 批处理和压缩
* 消费者拉模式：消费者根据自身处理能力主动拉取消息，避免了因为消息推送过快导致的过载问题，从而更好地控制流量和延迟。
* 高效的复制机制
* 灵活的存储配置
* 无锁数据结构

## Kafka如何保证消息不丢失

* 生产者
  * `acks=all`（或 `acks=-1`）：生产者等待所有同步副本确认接收到消息。这是最可靠的设置，确保消息被至少一个完整的副本集接收到。
  * 生产者配置 `retries` 参数来指定重试次数，如果发送失败，生产者会重试发送。
  * 启用生产者的幂等性（idempotence），通过设置 `enable.idempotence=true`，确保每条消息只会被写入一次，即使生产者重试发送。
* 消费者
  * 关闭自动提交 `offset`, 业务处理完成后手动commit，异常处理业务要考虑幂等性

* Broker端的消息保证
  * 给 `topic` 设置 `replication.factor` 参数：这个值必须大于 `1`，要求每个 `partition` 必须有至少 `2` 个副本
  * 在 `Kafka` 服务端设置 `min.insync.replicas` 参数：这个值必须大于 `1`，这个参数的含义是一个 `leader` 至少感知到有至少一个 `follower` 还跟自己保持联系，没掉队，这样才能确保 `leader` 挂了还有一个 `follower` 节点


## Kafka 如何保证消息的顺序性

Kafka分区内有序。

* 生产者：生产者在发送消息时，可以指定一个分区键（Partition Key）。例如order id作为分区键
* 消费者：消费者从分区读取消息时，是按照消息存储的顺序进行读取的。一个分区中的消息会按顺序被消费者读取和处理，保持了消息的顺序性。

## Kafka中的ISR、AR代表什么？ISR的伸缩指什么？

- `ISR`：In-Sync Replicas 副本同步队列
- `AR`:Assigned Replicas 所有副本

ISR是由leader维护，follower从leader同步数据有一些延迟（包括`延迟时间replica.lag.time.max.ms`和`延迟条数replica.lag.max.messages`两个维度），任意一个超过阈值都会把follower剔除出ISR，存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。

> AR=ISR+OSR。

## 为什么Kafka不支持读写分离？

1. 不通过读写分离，一样实现了负载均衡和高可用
2. 如果读写分离，面临数据一致性和数据延迟问题

## 分区和消费者的关系

在 Apache Kafka 中，关于消费者（consumer）和分区（partition）的分配和消费，有几个关键的规则和行为：

1. **一个消费者能消费多个分区吗？** 是的，一个消费者可以消费多个分区。当消费者数量少于分区数量时，每个消费者将会被分配多个分区来消费消息。
2. **一个分区能被多个消费者消费吗？** 不，一个分区只能被一个消费者消费。消费者组内的每个分区只能被分配给一个消费者。这样保证了分区内消息的顺序消费和消息的一致性。
3. **如果分区是 8，我有 9 个消费者，会发生什么？** 如果你有 8 个分区和 9 个消费者，那么其中一个消费者将不会被分配到任何分区，不会消费到任何消息。Kafka 的消费者组通过协调器（coordinator）来分配分区，每个分区只会被分配给一个消费者。如果消费者数量多于分区数量，那么多出来的消费者将处于空闲状态，不进行消息消费。











